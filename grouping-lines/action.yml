name: Grouping Lines Demo
description: "Demonstrate GitHub Actions log grouping with nested groups, loops, and notices"
author: actions-lfraile
branding:
  icon: layers
  color: blue

inputs:
  title:
    description: Top-level group title
    required: false
    default: "Grouping Lines Demo"
  nested-levels:
    description: Number of nested groups to demonstrate (0-5)
    required: false
    default: "2"
  items:
    description: Comma-separated items to iterate and group (e.g., alpha,beta,gamma)
    required: false
    default: "alpha,beta,gamma"
  warn-on:
    description: If an item matches this value, emit a warning inside its group
    required: false
    default: ""

runs:
  using: composite
  steps:
    - name: Run grouping demo
      shell: bash
      env:
        NESTED: ${{ inputs['nested-levels'] }}
        ITEMS: ${{ inputs.items }}
        WARN_ON: ${{ inputs['warn-on'] }}
      run: |
        echo "::group::${{ inputs.title }} — $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
        echo "Runner OS: $RUNNER_OS"
        echo "Shell: $SHELL"
        echo "Repository: $GITHUB_REPOSITORY"
        echo "Ref: $GITHUB_REF"
        echo "Commit: $GITHUB_SHA"
        echo "::notice title=Heads up::You're about to see nested groups and iterated sections."

        # Nested groups
        if [[ ! "$NESTED" =~ ^[0-9]+$ ]]; then NESTED=0; fi
        if (( NESTED > 5 )); then NESTED=5; fi
        depth=$NESTED
        if (( depth == 0 )); then
          echo "(Skipping nested demo — depth is 0)"
        else
          for ((i=1;i<=depth;i++)); do
            echo "::group::Nested level $i/$(($depth))"
            echo "Creating some sample output at level $i..."
            printf '• sample line %d at level %d\n' 1 "$i"
            printf '• sample line %d at level %d\n' 2 "$i"
          done
          for ((i=depth;i>=1;i--)); do
            echo "::endgroup::"
          done
        fi

        # Iterated item groups
        IFS=',' read -ra parts <<< "$ITEMS"
        if (( ${#parts[@]} == 0 )); then
          echo "(No items to iterate)"
        fi
        for item in "${parts[@]}"; do
          item_trimmed="${item## }"; item_trimmed="${item_trimmed%% }"
          title="Item: ${item_trimmed:-<empty>}"
          echo "::group::${title}"
          echo "Processing '$item_trimmed' at $(date +'%H:%M:%S')"
          echo "Random sample (0-99): $((RANDOM % 100))"
          if [[ -n "$WARN_ON" && "$item_trimmed" == "$WARN_ON" ]]; then
            echo "::warning title=Attention::$item_trimmed matched warn-on input"
          fi
          # Simple progress bar effect
          for n in 1 2 3; do
            printf 'step %d for %s\n' "$n" "$item_trimmed"
            sleep 0.1
          done
          echo "::endgroup::"
        done

        echo "::endgroup::"
